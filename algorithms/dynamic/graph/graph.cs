/*
 * Dafny executable code example.
 *
 * To compile you need to link with the assembly generated by Dafny
 * for «floyd.dfy».
 *
 * In Mono:	mcs -reference:floyd.dll graph.cs
 * In MSV:	csc /reference:floyd.dll graph.cs
 */

using System;
using System.IO;
using System.Text.RegularExpressions;
using System.Collections.Generic;

/**
 * XReal extension to make code more readable.
 */
public static class XRealExtension
{
	public static string ToText(this xreal x)
	{
		if (x.is_Infty)
			return "∞";

		Dafny.BigRational val = x.dtor_value;

		return val.ToString().Replace("(", "").Replace(")", "").Replace("/ 1.0", "").Replace(".0 ", "");
	}
}

class GraphParser
{
	/**
	 * Creates a xreal infinity.
	 */
	public static xreal Infty()
	{
		return new xreal(new xreal_Infty());
	}

	/**
	 * Creates a xreal from an int.
	 */
	public static xreal XFromInt(int val)
	{
		return new xreal(new xreal_Real(new Dafny.BigRational(val)));
	}

	public xreal[,] Parse(StreamReader sr)
	{
		string line;

		Dictionary<string, int> vertices = new Dictionary<string, int>();
		Queue<Tuple<int, int, xreal>> values = new Queue<Tuple<int, int, xreal>>();

		Regex linefmt = new Regex(@"([^\s]+)\s+([^\s]+)\s+(-?\d+)(\s+-)?");

		while ((line = sr.ReadLine()) != null)
		{
			// Lines starting with colon are comments
			if (line.StartsWith(":"))
				continue;

			var mat = linefmt.Match(line);

			if (!mat.Success)
				throw new FormatException("wrong line format \"" + line + "\"");

			var origin =	mat.Groups[1].Value;
			var dest =	mat.Groups[2].Value;

			if (!vertices.ContainsKey(origin))
				vertices[origin] = vertices.Count;

			if (!vertices.ContainsKey(dest))
				vertices[dest] = vertices.Count;

			int val;

			if (!Int32.TryParse(mat.Groups[3].Value, out val))
				throw new FormatException("not a number \"" + val + "\"");

			values.Enqueue(Tuple.Create(vertices[origin], vertices[dest], XFromInt(val)));

			if (mat.Groups[4].Value != "")
				values.Enqueue(Tuple.Create(vertices[dest], vertices[origin], XFromInt(val)));
		}

		xreal[,] ret = new xreal[vertices.Count, vertices.Count];


		// Initializes the matrix as default

		for (int i = 0; i < vertices.Count; i++)
			for (int j = 0; j < vertices.Count; j++)
				if (i == j)
					ret[i, j] = XFromInt(0);
				else
					ret[i, j] = Infty();

		// Initializes the matrix with the given values

		foreach (var val in values)
		{
			ret[val.Item1, val.Item2] = val.Item3;
		}

		VertNames = new List<string>(vertices.Keys);

		return ret;
	}

	/**
	 * The lists of vertices names.
	 */
	public List<string> VertNames;
}

class DafnyExample
{
	/**
	 * Prints a matrix of xreals.
	 */
	public static void PrintMatrix(xreal[,] matrix)
	{
		for (int i = 0; i < matrix.GetLength(0); i++) {

			for (int j = 0; j < matrix.GetLength(1); j++) {
				Console.Write(matrix[i, j].ToText() + "\t");
			}

			Console.WriteLine();

		}
	}

	public static int Main(string[] args)
	{
		if (args.Length != 1)
		{
			Console.Error.WriteLine("No input file.");

			return 3;
		}

		if (!File.Exists(args[0]))
		{
			Console.Error.WriteLine(args[0] + ": no such file.");
		}

		// Parses the file and calls Floyd algorithm

		try {
			var parser = new GraphParser();

			// Gets input data from file
			xreal [,] datos = parser.Parse(File.OpenText(args[0]));

			xreal[,] res = null;

			Console.WriteLine("Input data:");
			Console.WriteLine(String.Join("\t", parser.VertNames));

			PrintMatrix(datos);

			__default.Floyd(datos, out res);

			Console.WriteLine();
			Console.WriteLine("Output data:");

			PrintMatrix(res);

		}

		catch (Exception e)
		{
			Console.ForegroundColor = ConsoleColor.Red;
			Console.Error.WriteLine("Error: " + e.Message);
			Console.ResetColor();
		}

		return 0;
	}

}
